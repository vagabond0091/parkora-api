---
description: JUnit testing conventions and best practices for Parkora API test cases
globs: api/src/test/java/com/parkora/**
---

# Parkora JUnit Testing Conventions

## Testing Strategy and Priorities

- **Primary focus: Service implementation tests**  
  - The service layer contains the core business logic and should be the primary focus of testing.  
  - Controllers are thin layers that primarily handle HTTP concerns (request/response mapping, status codes).  
  - Service tests verify business rules, data validation, error handling, and integration with repositories.  
  - All service implementation classes (`*ServiceImpl`) must have comprehensive test coverage with both positive and negative test cases.

- **Controller tests: Optional and minimal**  
  - Controllers typically just delegate to services and map DTOs, so comprehensive controller testing is often redundant.  
  - Controller tests are optional unless the controller has complex request/response mapping or validation logic.  
  - If controller tests are needed, focus on:  
    - HTTP status code verification  
    - Request validation annotations (`@Valid`, `@NotBlank`, etc.)  
    - Response DTO mapping  
    - Security/authorization annotations  
  - Use `@WebMvcTest` for isolated controller testing, or `@SpringBootTest` with `MockMvc` for integration-style tests when needed.

- **Repository tests: Only when needed**  
  - Repository tests are typically not necessary when using Spring Data JPA.  
  - Only test repositories if they contain custom query methods with complex logic.  
  - For standard CRUD operations, service tests provide sufficient coverage.

- **Integration tests: For critical flows**  
  - Write integration tests (`@SpringBootTest`) for critical end-to-end flows (e.g., authentication, registration).  
  - Integration tests verify the integration between multiple layers (controller → service → repository).  
  - Use sparingly due to slower execution time; prefer service unit tests when possible.

## Test Structure and Naming

- **Test class naming**  
  - Test classes must end with `Test` or `Tests` suffix.  
  - Test class name should match the class under test with `Test` suffix (e.g., `UserServiceTest` for `UserService`).  
  - Use `@ExtendWith(MockitoExtension.class)` for unit tests or `@SpringBootTest` for integration tests.

- **Test method naming**  
  - Test methods should be descriptive and follow the pattern: `methodName_scenario_expectedBehavior()`.  
  - Use camelCase for test method names.  
  - Example: `registerUser_withValidRequest_shouldReturnSuccess()`, `registerUser_withDuplicateEmail_shouldThrowException()`.

## Given-When-Then Pattern

- **All test cases must follow the Given-When-Then (Arrange-Act-Assert) pattern**  
  - **Given (Arrange)**: Set up test data, mock dependencies, and prepare the test environment.  
  - **When (Act)**: Execute the method or action being tested.  
  - **Then (Assert)**: Verify the expected outcome, verify mock interactions, and assert results.  
  - Use clear comments to separate the three phases.

- **Example structure:**
  ```java
  @Test
  void registerUser_withValidRequest_shouldReturnSuccess() {
      // Given
      RegisterRequest request = RegisterRequest.builder()
          .username("john.doe")
          .email("john@example.com")
          .password("password123")
          .build();
      
      User savedUser = User.builder()
          .id(1L)
          .username("john.doe")
          .email("john@example.com")
          .build();
      
      when(userRepository.findByUsername(request.getUsername())).thenReturn(Optional.empty());
      when(userRepository.findByEmail(request.getEmail())).thenReturn(Optional.empty());
      when(userRepository.save(any(User.class))).thenReturn(savedUser);
      
      // When
      User result = registerService.register(request);
      
      // Then
      assertThat(result).isNotNull();
      assertThat(result.getUsername()).isEqualTo("john.doe");
      assertThat(result.getEmail()).isEqualTo("john@example.com");
      verify(userRepository).save(any(User.class));
  }
  ```

- **Extract reusable Given setup into helper methods**  
  - If the Given (arrange) phase is used in multiple test cases, move it to a private helper method.  
  - Helper methods should be descriptive and clearly indicate what they're setting up.  
  - Use method parameters to customize the setup for different test scenarios.  
  - This reduces code duplication and makes tests more maintainable.

- **Example with helper methods:**
  ```java
  @ExtendWith(MockitoExtension.class)
  class RegisterServiceTest {
      
      @Mock
      private UserRepository userRepository;
      
      @Mock
      private RoleRepository roleRepository;
      
      @InjectMocks
      private RegisterServiceImpl registerService;
      
      // Helper method for common setup
      private RegisterRequest createValidRegisterRequest() {
          return RegisterRequest.builder()
              .username("john.doe")
              .email("john@example.com")
              .password("password123")
              .firstName("John")
              .lastName("Doe")
              .build();
      }
      
      // Helper method with parameters for flexibility
      private User createUser(Long id, String username, String email) {
          return User.builder()
              .id(id)
              .username(username)
              .email(email)
              .build();
      }
      
      // Helper method for mocking repository behavior
      private void mockUserNotFound(String username, String email) {
          when(userRepository.findByUsername(username)).thenReturn(Optional.empty());
          when(userRepository.findByEmail(email)).thenReturn(Optional.empty());
      }
      
      @Test
      void registerUser_withValidRequest_shouldReturnSuccess() {
          // Given
          RegisterRequest request = createValidRegisterRequest();
          User savedUser = createUser(1L, "john.doe", "john@example.com");
          
          mockUserNotFound(request.getUsername(), request.getEmail());
          when(userRepository.save(any(User.class))).thenReturn(savedUser);
          
          // When
          User result = registerService.register(request);
          
          // Then
          assertThat(result).isNotNull();
          assertThat(result.getUsername()).isEqualTo("john.doe");
          verify(userRepository).save(any(User.class));
      }
      
      @Test
      void registerUser_withDuplicateUsername_shouldThrowException() {
          // Given
          RegisterRequest request = createValidRegisterRequest();
          User existingUser = createUser(1L, "john.doe", "john@example.com");
          
          when(userRepository.findByUsername(request.getUsername()))
              .thenReturn(Optional.of(existingUser));
          
          // When & Then
          assertThatThrownBy(() -> registerService.register(request))
              .isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("Username already exists");
          
          verify(userRepository, never()).save(any(User.class));
      }
  }
  ```

- **When to extract helper methods**  
  - Extract when the same Given setup appears in 2 or more test methods.  
  - Extract when setup logic is complex and would benefit from being readable as a method call.  
  - Do not extract one-off setup that is specific to a single test case.

## Positive and Negative Test Cases

- **Every test method must have both positive and negative test cases**  
  - **Positive tests** verify the expected happy path behavior when valid inputs are provided.  
  - **Negative tests** verify error handling, edge cases, and invalid input scenarios.  
  - Use separate test methods for positive and negative scenarios.

- **Positive test case naming**  
  - Include positive scenario in method name: `methodName_withValidInput_shouldReturnSuccess()`.  
  - Example: `authenticateUser_withValidCredentials_shouldReturnJwtToken()`.

- **Negative test case naming**  
  - Include negative scenario in method name: `methodName_withInvalidInput_shouldThrowException()` or `methodName_whenResourceNotFound_shouldReturnError()`.  
  - Examples:  
    - `registerUser_withDuplicateEmail_shouldThrowIllegalArgumentException()`  
    - `getUserById_whenUserNotFound_shouldThrowNotFoundException()`  
    - `updateUser_withInvalidId_shouldReturnBadRequest()`.

- **Common negative test scenarios**  
  - Invalid input (null, empty, invalid format).  
  - Resource not found (404 scenarios).  
  - Validation failures (400 scenarios).  
  - Duplicate resource conflicts (409 scenarios).  
  - Unauthorized access (401 scenarios).  
  - Forbidden access (403 scenarios).  
  - Internal server errors (500 scenarios).

## Mocking Patterns

- **Use `@Mock` or `Mockito.mock()` for dependencies**  
  - Mock all external dependencies (repositories, services, clients).  
  - Use `@InjectMocks` for the class under test when using `@ExtendWith(MockitoExtension.class)`.  
  - Use `@MockBean` for Spring Boot integration tests to replace Spring beans.

- **Mock setup in Given phase**  
  - Configure mock behavior using `when().thenReturn()`, `when().thenThrow()`, `doNothing().when()`, etc.  
  - Set up mock return values based on the test scenario.  
  - Use `ArgumentMatchers` (e.g., `any()`, `anyString()`, `eq()`) when matching arguments.

- **Verify mock interactions in Then phase**  
  - Use `verify()` to ensure methods were called with expected parameters.  
  - Use `verifyNoMoreInteractions()` to ensure no unexpected method calls occurred.  
  - Verify the number of invocations when relevant: `verify(mock, times(n))`, `verify(mock, never())`.

- **Example with mocks:**
  ```java
  @ExtendWith(MockitoExtension.class)
  class RegisterServiceTest {
      
      @Mock
      private UserRepository userRepository;
      
      @Mock
      private RoleRepository roleRepository;
      
      @Mock
      private PasswordEncoder passwordEncoder;
      
      @InjectMocks
      private RegisterServiceImpl registerService;
      
      @Test
      void registerUser_withDuplicateEmail_shouldThrowException() {
          // Given
          RegisterRequest request = RegisterRequest.builder()
              .username("john.doe")
              .email("existing@example.com")
              .password("password123")
              .build();
          
          when(userRepository.findByEmail(request.getEmail()))
              .thenReturn(Optional.of(User.builder().build()));
          
          // When & Then
          assertThatThrownBy(() -> registerService.register(request))
              .isInstanceOf(IllegalArgumentException.class)
              .hasMessageContaining("Email already exists");
          
          verify(userRepository, never()).save(any(User.class));
      }
  }
  ```

## Test Annotations and Setup

- **Unit tests**  
  - Use `@ExtendWith(MockitoExtension.class)` for pure unit tests.  
  - Use `@Mock` and `@InjectMocks` annotations.  
  - Avoid loading Spring context unless necessary.

- **Integration tests**  
  - Use `@SpringBootTest` for full integration tests that require Spring context.  
  - Use `@AutoConfigureMockMvc` for web layer testing.  
  - Use `@MockBean` to replace Spring beans with mocks.  
  - Use `@Transactional` and `@Rollback` for database tests if needed.

- **Web layer tests (controllers)**  
  - Use `@WebMvcTest(ControllerClass.class)` for controller unit tests.  
  - Use `MockMvc` for HTTP request/response testing.  
  - Mock service layer dependencies with `@MockBean`.

- **Test data setup**  
  - Use `@BeforeEach` for common setup needed before each test.  
  - Use `@BeforeAll` for one-time setup before all tests (must be static).  
  - Initialize test data objects in the Given phase, not in setup methods unless truly shared.

## Assertions

- **Use AssertJ for assertions**  
  - Prefer AssertJ fluent assertions over JUnit assertions for better readability.  
  - Use `assertThat()` for all assertions.  
  - Use specific assertion methods: `isEqualTo()`, `isNotNull()`, `isInstanceOf()`, `hasMessage()`, etc.

- **Exception assertions**  
  - Use `assertThatThrownBy()` for testing exceptions.  
  - Chain assertions to verify exception type and message.  
  - Example:  
    ```java
    assertThatThrownBy(() -> service.method())
        .isInstanceOf(IllegalArgumentException.class)
        .hasMessageContaining("expected message");
    ```

- **Collection assertions**  
  - Use AssertJ collection assertions: `hasSize()`, `contains()`, `containsExactly()`, `isEmpty()`.  
  - Verify collection contents thoroughly.

- **Object assertions**  
  - Use field-by-field assertions when verifying complex objects.  
  - Use `usingRecursiveComparison()` for deep object comparison when needed.

## Test Coverage

- **Aim for comprehensive test coverage in service layer**  
  - **Service implementations**: Test all public methods in `*ServiceImpl` classes with comprehensive coverage.  
  - **Controllers**: Testing is optional; focus on service layer instead. Only test controllers when they have complex logic beyond simple delegation.  
  - Test both successful paths and error paths for all service methods.  
  - Test edge cases and boundary conditions.  
  - Test null, empty, and invalid input scenarios.

- **Test isolation**  
  - Each test should be independent and not rely on the execution order.  
  - Use `@BeforeEach` or `@AfterEach` to reset state between tests if needed.  
  - Avoid shared mutable state between tests.

## Integration Test Examples

- **Note: Controller tests are optional**  
  - Controller tests shown below are for reference when needed (e.g., testing validation, HTTP status codes, or security).  
  - Primary testing focus should be on service implementations.

- **Controller integration test example (when needed):**
  ```java
  @WebMvcTest(AuthController.class)
  class AuthControllerTest {
      
      @Autowired
      private MockMvc mockMvc;
      
      @MockBean
      private AuthenticationManager authenticationManager;
      
      @MockBean
      private JwtService jwtService;
      
      @MockBean
      private UserRepository userRepository;
      
      @Test
      void login_withValidCredentials_shouldReturnJwtToken() throws Exception {
          // Given
          LoginRequest request = LoginRequest.builder()
              .username("john.doe")
              .password("password123")
              .build();
          
          User user = User.builder()
              .username("john.doe")
              .build();
          
          Authentication auth = mock(Authentication.class);
          when(authenticationManager.authenticate(any())).thenReturn(auth);
          when(auth.getName()).thenReturn("john.doe");
          when(userRepository.findByUsername("john.doe")).thenReturn(Optional.of(user));
          when(jwtService.generateToken(user)).thenReturn("jwt-token");
          
          // When & Then
          mockMvc.perform(post("/api/v1/auth/login")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
              .andExpect(status().isOk())
              .andExpect(jsonPath("$.data").value("jwt-token"));
      }
      
      @Test
      void login_withInvalidCredentials_shouldReturnUnauthorized() throws Exception {
          // Given
          LoginRequest request = LoginRequest.builder()
              .username("invalid")
              .password("wrong")
              .build();
          
          when(authenticationManager.authenticate(any()))
              .thenThrow(new BadCredentialsException("Invalid credentials"));
          
          // When & Then
          mockMvc.perform(post("/api/v1/auth/login")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
              .andExpect(status().isUnauthorized());
      }
  }
  ```

## Best Practices

- **Keep tests simple and focused**  
  - Each test should verify one specific behavior.  
  - Avoid complex test logic; tests should be easy to understand.

- **Use descriptive variable names**  
  - Use meaningful names for test data (e.g., `validUser`, `duplicateEmailRequest`, `invalidPassword`).  
  - Avoid generic names like `user1`, `data`, `result` when more descriptive names would clarify intent.

- **Avoid test interdependencies**  
  - Do not rely on test execution order.  
  - Do not share mutable state between tests without proper cleanup.

- **Test real behavior, not implementation details**  
  - Test what the method does, not how it does it internally.  
  - Focus on public APIs and contracts rather than private implementation.

- **Use test builders or factory methods**  
  - Create helper methods for building complex test objects.  
  - Use Lombok `@Builder` for test data creation when appropriate.
