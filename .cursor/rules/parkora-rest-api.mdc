---
description: RESTful API conventions and best practices for Parkora API endpoints
globs: api/src/main/java/com/parkora/api/controller/**
---

# Parkora REST API Conventions

## API Base Path

- **All API endpoints must use the base path `/api/v1`**  
  - Use `@RequestMapping("/api/v1/{resource}")` at the controller level.  
  - The resource name should be derived from the controller class name by removing the "Controller" suffix and converting to lowercase.
  
- **Controller class name to URL path mapping**  
  - Controller class name: `UserController` → URL path: `/api/v1/user`  
  - Controller class name: `AuthController` → URL path: `/api/v1/auth`  
  - Controller class name: `UserProfileController` → URL path: `/api/v1/user-profile` (convert CamelCase to kebab-case)  
  - Controller class name: `OrderItemController` → URL path: `/api/v1/order-item`  
  - Example: `@RequestMapping("/api/v1/user")` for `UserController`, `@RequestMapping("/api/v1/auth")` for `AuthController`.

## HTTP Methods and Semantics

- **GET** – Retrieve resources (idempotent, no side effects)  
  - Use for fetching single resources or collections.  
  - Never use GET for operations that modify state.

- **POST** – Create new resources or perform actions  
  - Use for creating resources (returns `201 CREATED`).  
  - Use for non-idempotent operations (e.g., login, registration).  
  - Request body should contain the resource data.

- **PUT** – Replace/update entire resource (idempotent)  
  - Use when updating all fields of a resource.  
  - Client must send the complete resource representation.

- **PATCH** – Partial update (idempotent)  
  - Use when updating only specific fields of a resource.  
  - Client sends only the fields to be modified.

- **DELETE** – Remove resources (idempotent)  
  - Use for deleting resources.  
  - Returns `200 OK` with `ApiResponse` wrapper (data can be null or contain success message) on success.  
  - Returns `404 NOT FOUND` with `ApiResponse` wrapper containing error message if resource doesn't exist.

## URL Naming Conventions

- **Use plural nouns for resource names**  
  - **Correct:** `/api/v1/users`, `/api/v1/posts`, `/api/v1/orders`  
  - **Bad practice:** `/api/v1/user`, `/api/v1/post`, `/api/v1/order`

- **Use lowercase with hyphens for multi-word resources**  
  - **Correct:** `/api/v1/user-profiles`, `/api/v1/order-items`  
  - **Bad practice:** `/api/v1/userProfiles`, `/api/v1/user_profiles`

- **Use path variables for resource identifiers**  
  - **Correct:** `/api/v1/users/{id}`, `/api/v1/posts/{postId}`  
  - **Bad practice:** `/api/v1/users?id=123` (use query params only for filtering, not IDs)

- **Use nested paths for sub-resources**  
  - **Correct:** `/api/v1/users/{userId}/orders`, `/api/v1/posts/{postId}/comments`  
  - Ensure the parent resource exists before accessing sub-resources.

## HTTP Status Codes

- **200 OK** – Successful GET, PUT, PATCH requests  
  - Standard success response for retrieval and updates.

- **201 CREATED** – Successful POST that creates a new resource  
  - Include `Location` header with the URI of the created resource when appropriate.  
  - Response body should contain the created resource or its identifier.

- **204 NO CONTENT** – Successful DELETE or PUT/PATCH with no response body  
  - Use when the operation succeeds but no content needs to be returned.

- **400 BAD REQUEST** – Invalid request (validation errors, malformed data)  
  - Use for client errors in request format or validation failures.

- **401 UNAUTHORIZED** – Authentication required or failed  
  - Use when the client is not authenticated or credentials are invalid.

- **403 FORBIDDEN** – Authenticated but not authorized  
  - Use when the user is authenticated but lacks permission for the operation.

- **404 NOT FOUND** – Resource not found  
  - Use when the requested resource doesn't exist.

- **409 CONFLICT** – Resource conflict (e.g., duplicate username/email)  
  - Use when the request conflicts with the current state (e.g., unique constraint violation).

- **500 INTERNAL SERVER ERROR** – Server-side errors  
  - Avoid exposing internal error details in production responses.

## Request/Response Patterns

- **Always use DTOs for request/response bodies**  
  - Controllers must accept `*Request` DTOs (e.g., `LoginRequest`, `RegisterRequest`).  
  - Controllers must return `*Response` DTOs or `ResponseEntity<T>`.  
  - Never expose JPA entities directly in controller methods.

- **Use `@Valid` annotation for request validation**  
  - Apply `@Valid` to `@RequestBody` parameters to trigger Jakarta Bean Validation.  
  - Example: `public ResponseEntity<T> create(@Valid @RequestBody CreateRequest request)`

- **All API responses must use the generic `ApiResponse<T>` wrapper**  
  - Every endpoint must return `ResponseEntity<ApiResponse<T>>` where `T` is the actual data type.  
  - The `ApiResponse` wrapper must contain:  
    - `message` (String) – Descriptive message about the operation result.  
    - `errorCode` (Integer) – Numeric HTTP status code (e.g., 400, 404, 500). For success responses, use 200 or null.  
    - `status` (String) – Descriptive status indicator (e.g., "SUCCESS", "BAD_REQUEST", "INTERNAL_ERROR", "NOT_FOUND").  
    - `data` (T) – The actual response data (can be null for operations without data).  
  - Example success structure:  
    ```java
    ApiResponse<UserResponse> response = ApiResponse.<UserResponse>builder()
        .message("User retrieved successfully")
        .errorCode(200)
        .status("SUCCESS")
        .data(userResponse)
        .build();
    return ResponseEntity.ok(response);
    ```
  - Example error structure:  
    ```java
    ApiResponse<ErrorDetails> errorResponse = ApiResponse.<ErrorDetails>builder()
        .message("User not found")
        .errorCode(404)
        .status("NOT_FOUND")
        .data(null)
        .build();
    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    ```

- **Response types with `ApiResponse` wrapper**  
  - Single resource: `ResponseEntity<ApiResponse<ResourceResponse>>`  
  - Collection: `ResponseEntity<ApiResponse<List<ResourceResponse>>>`  
  - Success with no data: `ResponseEntity<ApiResponse<Void>>` or `ResponseEntity<ApiResponse<Object>>` with `data: null`  
  - Error responses: `ResponseEntity<ApiResponse<ErrorDetails>>` with appropriate status code and error message

## Error Handling

- **Use consistent error response structure**  
  - All error responses must use the `ApiResponse` wrapper with appropriate error details.  
  - The `message` field should contain a clear, actionable error message.  
  - The `errorCode` field must contain the numeric HTTP status code (e.g., 400, 404, 409, 500).  
  - The `status` field should contain a descriptive status string in UPPER_SNAKE_CASE (e.g., "BAD_REQUEST", "NOT_FOUND", "INTERNAL_ERROR", "CONFLICT", "VALIDATION_ERROR").  
  - The `data` field can contain additional error details, validation errors, or field-level validation errors.  
  - Common error code and status mappings:  
    - `400` → `"BAD_REQUEST"` or `"VALIDATION_ERROR"`  
    - `401` → `"UNAUTHORIZED"`  
    - `403` → `"FORBIDDEN"`  
    - `404` → `"NOT_FOUND"`  
    - `409` → `"CONFLICT"`  
    - `500` → `"INTERNAL_ERROR"`  
  - Example error response structure:  
    ```java
    ApiResponse<ErrorDetails> errorResponse = ApiResponse.<ErrorDetails>builder()
        .message("Validation failed")
        .errorCode(400)
        .status("BAD_REQUEST")
        .data(ErrorDetails.builder()
            .field("email")
            .message("Email is required")
            .build())
        .build();
    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    ```
  - Example internal server error:  
    ```java
    ApiResponse<Void> errorResponse = ApiResponse.<Void>builder()
        .message("An unexpected error occurred")
        .errorCode(500)
        .status("INTERNAL_ERROR")
        .data(null)
        .build();
    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    ```

- **Handle exceptions in controllers appropriately**  
  - Use `@ControllerAdvice` for global exception handling when possible.  
  - Avoid try-catch blocks in controllers unless handling specific business logic exceptions.  
  - Let validation exceptions be handled by Spring's validation framework.

- **Return meaningful error messages**  
  - Provide clear, actionable error messages to clients.  
  - Avoid exposing internal implementation details or stack traces.

## Authentication & Authorization

- **Use JWT tokens for authentication**  
  - Include JWT token in `Authorization: Bearer <token>` header.  
  - Validate tokens using `JwtAuthenticationFilter` or similar security filters.

- **Protect endpoints appropriately**  
  - Public endpoints: `/api/v1/auth/login`, `/api/v1/auth/register`  
  - Protected endpoints: Require valid JWT token.  
  - Use Spring Security annotations (`@PreAuthorize`, `@Secured`) for method-level security.

## Query Parameters & Filtering

- **Use query parameters for filtering, sorting, and pagination**  
  - Filtering: `/api/v1/users?role=ADMIN&status=ACTIVE`  
  - Sorting: `/api/v1/users?sort=createdAt&order=desc`  
  - Pagination: `/api/v1/users?page=0&size=20`

- **Use consistent pagination parameters**  
  - Standard: `page` (0-based) and `size` (items per page).  
  - Return pagination metadata in response (total count, total pages, etc.).

## Versioning (Future Consideration)

- **Consider API versioning for breaking changes**  
  - URL versioning: `/api/v1/users`, `/api/v2/users`  
  - Header versioning: `Accept: application/vnd.parkora.v1+json`  
  - Document versioning strategy if multiple versions will coexist.

## Documentation

- **Use descriptive method names**  
  - Method names should clearly indicate the operation (e.g., `registerUser`, `authenticateUser`).  
  - Avoid generic names like `handle`, `process`, `doSomething`.

- **Consider adding OpenAPI/Swagger annotations**  
  - Use `@Operation`, `@ApiResponse` for API documentation.  
  - Document request/response schemas, status codes, and error cases.
