---
description: Core architecture principles for the Parkora app
globs: api/src/main/java/com/parkora/**
---

# Parkora App Architecture
## Core Principles

- **Object-Oriented Design (OOP)**  
  - Encapsulate behavior and data inside cohesive classes.  
  - Favor composition over inheritance where possible.  
  - Model domain concepts explicitly (e.g., `User`, `Role`, `JwtProperties`).

- **DTOs for API Boundaries**  
  - Use dedicated DTOs for all controller inputs/outputs (`*Request`, `*Response`).  
  - Never expose JPA entities directly in controller responses.  
  - Keep DTOs free of persistence concerns (no JPA annotations).

- **SOLID Principles (applied to controllers and services)**  
  - **S – Single Responsibility**  
    - Controllers in `controller/` only handle HTTP concerns (routing, status codes, mapping DTOs).  
    - Services in `service/` / `service/impl/` own the business logic and orchestration, not controllers.  
  - **O – Open/Closed**  
    - Add new behavior by adding new service methods or implementations rather than bloating existing controllers.  
    - Controllers call service interfaces; new flows are introduced in the service layer.  
  - **L – Liskov Substitution**  
    - Controllers depend on service **interfaces** (e.g., `RegisterService`), and any `*Impl` must be interchangeable without controller changes.  
  - **I – Interface Segregation**  
    - Prefer multiple small, focused service interfaces (e.g., auth, registration, user query) instead of one overly large, catch‑all service.  
    - Controllers inject only the interfaces they actually need.  
  - **D – Dependency Inversion**  
    - High-level modules (controllers, orchestration services) depend on abstractions in `service/`, not on `repository/` or concrete `*Impl` classes.  
    - Spring wires implementations (`service/impl/`) into these interfaces.

- **DRY (Don’t Repeat Yourself)**  
  - Extract shared logic into `service/common`, `util`, or reusable helper methods.  
  - Avoid duplicating validation, mapping, or security code across controllers/services.  
  - Prefer central configuration and constants for cross-cutting concerns.

## Root-Level Structure

<!-- 
Root-level structure for the Parkora API application.
All Java source code follows this directory organization under com.parkora.api package.
-->

```
parkora/api/
├── config/                 # Configuration classes (SecurityConfig, JwtProperties, etc.)
├── controller/             # REST API controllers
├── dto/                    # Data Transfer Objects (request/response DTOs)
├── entity/                 # JPA entities and domain models
│   └── common/             # Common base entities
├── repository/             # Spring Data JPA repositories
├── util/                   # Shared utilities and helper classes
├── lib/                    # Third-party library integrations
├── providers/              # External service providers
├── security/               # Security-related classes (filters, etc.)
├── service/                # Business logic service layer
│   ├── common/             # Common service base classes and utilities
│   └── impl/               # Service implementations
└── test/                   # Test utilities and helpers
```

## Naming Conventions
- **Files / Classes / Enums**  
  - Use **PascalCase** for Java types and filenames (e.g., `AuthController.java`, `RegisterServiceImpl.java`, `JwtProperties.java`).  
  - File names must match the primary public class in the file.

- **Variables / Fields / Parameters / Local objects**  
  - Use **camelCase** (e.g., `jwtService`, `registerRequest`, `userRepository`).  
  - Avoid ambiguous short names; prefer descriptive names that express intent.

- **Packages**  
  - Use **lowercase dot‑separated package names** (e.g., `com.parkora.api.controller`, `com.parkora.api.service.impl`).  
  - Do not use uppercase letters, underscores, or hyphens in package names.
